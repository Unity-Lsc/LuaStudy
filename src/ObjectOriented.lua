--- 面向对象
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by LSC.
--- DateTime: 2020/7/2 23:06
---

---self机制
--点号和冒号的区别 用冒号定义的函数,多一个机制self
local a = {};
function a.test(self)
    print("a.test",self);
end
a.test(a);--a.test  table

local b = {};
function b:test(a,b)--会隐式的把self传递进去
    print("b:test",self);--self,调用这个函数的表的实例
    print(a,b);
end
b:test(3,4);--b:test   table     3  4
b.test(3,4);--b:test   3         4  nil
b.test(b,3,4);--b:test  table    3  4   显式的传递self

function b.test2()
    print("b.test2",self);
end
b:test2();--b.test2 nil

--self机制要正常运行,需要有两个点
--1.定义的函数必须使用冒号才会有隐式的传递self机制
--2.调用的时候,也要使用冒号

---end******************************************************************************************************************

---元表

local a = {};
local meta_a = {
    __index = {
      name = "lsc",
      age = 26,
      sex = 1,
    },
};

--两个表相加.第一个参数是表,第二个参数也是表  meta_a叫做a的元表
setmetatable(a,meta_a);--设置表的元表
print("a的元表:",getmetatable(a));--获得一个表的元表

--元表里面有一个重要的key __index
--如果在一个表里找不到某个key,lua解释器会在这个表的元表的__index表里面去进行查找
print("name:"..a.name,"age:"..a.age,"sex:"..a.sex);--name:lsc   age:26  sex:1

---end******************************************************************************************************************

---面向对象
--lua没有面向对象的概念.但是可以模拟出面向对象

local base = {};

--成员函数
function base:test()
    print("base:test",self);
    print("name:" .. self.name,"age:" .. self.age);
end

function base:new(instance)
    if not instance then
        instance = {};
    end
    setmetatable(instance,{__index = self});
    print("base:new");
    return instance;
end

local bbb = base:new({
    name = "lsc",
    age = 26,
    sex = 1,
});
print("bbb instance:",bbb);
bbb:test();
print("name:" .. bbb.name,"age:" .. bbb.age);

--面向对象的基本步骤
--1.定义一个类的表
--2.定义一个实例的表
--3.为这个实例的表加一个元素,并且元素__index指向了这个类的表
--4.利用self机制,当 表的实例:表的函数的时候,隐式的帮我们传递这个 实例的表 为self,

---end******************************************************************************************************************


---继承

--基类的表
local Person = {};

function Person:test()
    print("Person:test",self);
end

function Person:getAge()
    print("Person:getAge:",self);
end
--

function Person:new(instance)
    if not instance then
        instance = {};--类的实例
    end
    setmetatable(instance,{__index = self});
    return instance;
end

--子类的表
local man = Person:new();
print("man:",man);
function man:man_test()
    print("man:man_test",self);
end

function man:man_testtwo()
    print("man:man_testtwo",self);
end
--

local lily = man:new();--new 的self不再是Person,而是man  lily的元表里面的__index = man
print("lily",lily);
lily:man_test();--在man里面找到
lily:getAge();--在Person里面找到

---end******************************************************************************************************************


---重写

function man:test()
    Person.test(self);
    print("man:test",self);
end

lily:test();

---end******************************************************************************************************************
